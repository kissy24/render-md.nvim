# 引用符のネストと連続行のレンダリング問題

## 概要

引用符のレンダリングにおいて、複数の問題が確認されている。

1.  **連続した行での問題:** `> hoge\n> fuga` のような場合、2行目以降の引用符がレンダリングされない。
2.  **ネストと連続が組み合わさった場合の問題:** `> hoge\n>> fuga` のような場合、2行目が `>┃fuga` のように、レンダリングされていないマーカーとレンダリングされたマーカーが混在して表示される。

これまでの修正（子ノードのループ、マーカーへの直接クエリ）では、Tree-sitterが生成する複雑なツリー構造に完全に対応できず、問題の解決には至らなかった。

##根本原因

Tree-sitterがMarkdownを解析する際、連続した行やネストした引用符の `>` マーカーは、必ずしもトップレベルの `block_quote` ノードの直接の子になるとは限らない。しばしば `paragraph` ノードやネストした `block_quote` ノードの内部に配置される。そのため、単純な子ノードの走査ではこれらのマーカーを検出できない。

## 最終的な解決策

`block_quote` ノードをキャプチャする基本のアプローチに戻り、ハンドラ内で**再帰的な探索関数**を実装する。このアプローチにより、複雑なツリー構造のどこにあっても全ての `>` マーカーを捕捉する。

1.  **クエリ:** `(block_quote) @quote` を使用し、引用ブロックの最も外側のノードをキャプチャする。
2.  **再帰関数 `find_and_render_markers(node)`:**
    *   与えられたノードの子をすべて走査する。
    *   もし子のタイプが匿名ノード `>` であれば、それをマーカーとして扱い、アイコンを描画（concealとvirt_textを設定）する。
    *   もし子が `block_quote` または `paragraph` ノードであれば、その子に対して `find_and_render_markers` を再帰的に呼び出す。これにより、ツリーのより深い階層にあるマーカーも検出できる。
    *   他の主要なキャプチャ（`list_item`, `fenced_code_block` など）に対応するノードタイプへの再帰は行わず、意図しない二重レンダリングや無限ループを防ぐ。

この実装により、あらゆるパターンの引用符を正確にレンダリングすることが期待される。
